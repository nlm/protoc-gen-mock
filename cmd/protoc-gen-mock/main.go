package main

import (
	"fmt"
	"io/ioutil"
	"log"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var generatedErrors = map[string]string{
	"ErrWrongArgType":  "wrong argument type for this method",
	"ErrUnknownMethod": "unknown method name",
	"ErrEmptyResponse": "empty response to register",
}

var generatedImports = []Import{
	{Name: "context"},
	{Name: "errors"},
	{Name: "google.golang.org/grpc"},
	{Name: "google.golang.org/protobuf/encoding/protojson"},
	{Name: "google.golang.org/genproto/googleapis/rpc/status"},
	{Name: "google.golang.org/grpc/status", Alias: "spb"},
}

func KindDefaultValue(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return fmt.Sprint(false)
	case protoreflect.StringKind:
		return "\"string\""
	case protoreflect.BytesKind:
		return "[]byte(\"bytes\")"
	case protoreflect.EnumKind:
		return "0"
	case protoreflect.DoubleKind,
		protoreflect.Fixed32Kind,
		protoreflect.Fixed64Kind,
		protoreflect.FloatKind,
		protoreflect.Int32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Sfixed64Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sint64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Uint64Kind:
		return "0"
	case protoreflect.MessageKind:
		// FIXME
		return "nil"
	default:
		return ""
	}
}

func MockFieldValue(field *protogen.Field) string {
	return KindDefaultValue(field.Desc.Kind())
}

func genHeader(file *protogen.File, genFile *protogen.GeneratedFile) error {
	genFile.P("// Code generated by protoc-gen-mock. DO NOT EDIT.")
	genFile.P("// source: ", *file.Proto.Name)
	genFile.P("")
	genFile.P("package ", file.GoPackageName)
	return nil
}

func genImports(file *protogen.File, genFile *protogen.GeneratedFile) error {
	genFile.P("import (")
	for _, i := range generatedImports {
		genFile.P(i)
	}
	genFile.P(")")
	return nil
}

func genErrors(file *protogen.File, genFile *protogen.GeneratedFile) error {
	genFile.P("var (")
	for name, desc := range generatedErrors {
		genFile.P(name, " = errors.New(\"", desc, "\")")
	}
	genFile.P(")")
	return nil
}

func Generate(gen *protogen.Plugin) error {
	log.Print("----- START PLUGIN -----")
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}
		fileName := file.GeneratedFilenamePrefix + ".mock.go"
		genFile := gen.NewGeneratedFile(fileName, "")
		log.Print("----- BEGIN FILE ", file.Desc.Path(), " -----")

		generators := []GenFunc{
			genHeader,
			genImports,
			genErrors,
		}
		for _, f := range generators {
			if err := f(file, genFile); err != nil {
				return err
			}
			genFile.P("")
		}

		// Services
		for _, s := range file.Services {
			baseServerName := s.GoName + "Server"
			mockServerName := "Mock" + baseServerName

			// type MockXServer
			genFile.P("type ", mockServerName, " struct {")
			genFile.P("Unimplemented", baseServerName)
			// contents
			genFile.P("contents struct {")
			for _, m := range s.Methods {
				genFile.P(m.GoName, " *", m.Output.GoIdent.GoName)
			}
			genFile.P("}")
			// errors
			genFile.P("errors struct {")
			for _, m := range s.Methods {
				genFile.P(m.GoName, " error")
			}
			genFile.P("}")
			genFile.P("}")

			// RegisterMockResponse
			genFile.P("func (ms *", mockServerName, ") RegisterMockResponse(method string, response any) error {")
			genFile.P("switch method {")
			for _, m := range s.Methods {
				genFile.P("case \"", m.GoName, "\":")
				genFile.P("switch r := response.(type) {")
				genFile.P("case error:")
				genFile.P("ms.errors.", m.GoName, " = r")
				genFile.P("case *", m.Output.GoIdent.GoName, ":")
				genFile.P("ms.contents.", m.GoName, " = r")
				genFile.P("default:")
				genFile.P("return ErrWrongArgType")
				genFile.P("}")
			}
			genFile.P("default:")
			genFile.P("return ErrUnknownMethod")
			genFile.P("}")
			genFile.P("return nil")
			genFile.P("}")

			// RegisterJSONMockContent
			genFile.P("// RegisterJSONMockContent registers a JSON string as a Mock content,")
			genFile.P("// making sure that the format is respected")
			genFile.P("func (ms *", mockServerName, ") RegisterJSONMockContent(method string, payload []byte) error {")
			genFile.P("switch method {")
			for _, m := range s.Methods {
				genFile.P("case \"", m.GoName, "\":")
				genFile.P("var content = new(", m.Output.GoIdent.GoName, ")")
				genFile.P("if err := protojson.Unmarshal(payload, content); err != nil {")
				genFile.P("return err")
				genFile.P("}")
				genFile.P("ms.contents.", m.GoName, " = content")
			}
			genFile.P("default:")
			genFile.P("return ErrUnknownMethod")
			genFile.P("}")
			genFile.P("return nil")
			genFile.P("}")

			// RegisterJSONMockStatus
			genFile.P("// RegisterJSONMockStatus registers a JSON string as a Mock status,")
			genFile.P("// making sure that the format is respected")
			genFile.P("func (ms *", mockServerName, ") RegisterJSONMockStatus(method string, payload []byte) error {")
			genFile.P("switch method {")
			for _, m := range s.Methods {
				genFile.P("case \"", m.GoName, "\":")
				genFile.P("var sta = new(status.Status)")
				genFile.P("if err := protojson.Unmarshal(payload, sta); err != nil {")
				genFile.P("return err")
				genFile.P("}")
				genFile.P("ms.errors.", m.GoName, " = spb.ErrorProto(sta)")
			}
			genFile.P("default:")
			genFile.P("return ErrUnknownMethod")
			genFile.P("}")
			genFile.P("return nil")
			genFile.P("}")

			// Methods
			for _, m := range s.Methods {
				genFile.P("func (ms *", mockServerName, ") ", m.GoName, "(ctx context.Context, req *", m.Input.GoIdent.GoName, ") (*", m.Output.GoIdent.GoName, ", error) {")

				// check registered errors
				genFile.P("if ms.errors.", m.GoName, " != nil {")
				genFile.P("return nil, ms.errors.", m.GoName)
				genFile.P("}")

				// check registered response
				genFile.P("if ms.contents.", m.GoName, " != nil {")
				genFile.P("return ms.contents.", m.GoName, ", nil")
				genFile.P("}")

				// return defaut value
				genFile.P("return &", m.Output.GoIdent.GoName, "{")
				for _, f := range m.Output.Fields {
					// o := f.Desc.Options().ProtoReflect().GetUnknown()
					// genFile.P("// Options: ", o, " ", o.IsValid())
					genFile.P(f.GoName, ": ", MockFieldValue(f), ",")
				}
				genFile.P("}, nil")
				genFile.P("}")
			}

			// func RegisterXServer()
			genFile.P("func Register", mockServerName, "(s grpc.ServiceRegistrar) (*", mockServerName, ") {")
			genFile.P("ms := &", mockServerName, "{}")
			genFile.P("Register", baseServerName, "(s, ms)")
			genFile.P("return ms")
			genFile.P("}")
		}

		// genFile.P("import \"fmt\"")
		// for _, message := range file.Messages {
		// 	genFile.P("func (*", message.GoIdent.GoName, ") HelloWorld() {")
		// 	genFile.P("fmt.Println(\"Hello, ", message.GoIdent.GoName, "!\")")
		// 	genFile.P("}")
		// }
		log.Print("----- END FILE ", file.Desc.Path(), " -----")
	}
	log.Print("----- END PLUGIN -----")
	return nil
}

func main() {
	//log.SetOutput(os.Stderr)
	log.SetOutput(ioutil.Discard)
	protogen.Options{}.Run(Generate)
}
